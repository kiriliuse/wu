'use strict';

var unistUtilVisit = require('unist-util-visit');
var rangeParser = require('parse-numeric-range');
var shiki = require('shiki');
var unified = require('unified');
var rehypeParse = require('rehype-parse');
var hashObj = require('hash-obj');
var hastUtilToString = require('hast-util-to-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var rangeParser__default = /*#__PURE__*/_interopDefaultLegacy(rangeParser);
var rehypeParse__default = /*#__PURE__*/_interopDefaultLegacy(rehypeParse);
var hashObj__default = /*#__PURE__*/_interopDefaultLegacy(hashObj);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isShikiTheme(value) {
  return value ? hasOwnProperty(value, 'tokenColors') : false;
}
function isElement(value) {
  return value ? value.type === 'element' : false;
}
function isText(value) {
  return value ? value.type === 'text' : false;
}
function hasOwnProperty(object, string) {
  return {}.hasOwnProperty.call(object, string);
}

function splitElement({
  elements,
  elementToWrap,
  innerString,
  rightString,
  leftString,
  rest,
  nextElementContinues,
  index,
  ignoreChars
}) {
  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== 'text' || ignoreChars) {
    return [elementToWrap, index];
  }
  let newIndex = index;

  // assign the matched value to the current element
  const textElement = elementToWrap.children[0];
  if (isText(textElement)) {
    textElement.value = innerString;
  }
  let rightStr = rightString;
  const leftStr = leftString;

  // append any repetitions to the right if necessary
  if (rest.length > 0) {
    rightStr += rest.map(s => s === '' ? innerString : innerString + s).join('');
  }
  if (leftStr.length > 0) {
    elements.splice(newIndex, 0, {
      ...elementToWrap,
      properties: {
        ...elementToWrap.properties
      },
      children: [{
        type: 'text',
        value: leftStr
      }]
    });
  }
  if (rightStr.length > 0 && !nextElementContinues) {
    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;
    elements.splice(newIndex, 0, {
      ...elementToWrap,
      properties: {
        ...elementToWrap.properties
      },
      children: [{
        type: 'text',
        value: rightStr
      }]
    });
  }
  return [elementToWrap, index + 1];
}

/**
 * Look ahead to determine if further, sibling nodes continue the string.
 */
function nextElementMaybeContinuesChars({
  elements,
  nextIndex,
  remainingPart
}) {
  if (remainingPart === '') {
    return false;
  }
  const nextNode = elements[nextIndex];
  const content = getContent(nextNode);
  if (!content) {
    return false;
  }
  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);
  const overlap = findOverlap(content, remainingPart);
  if (overlap === remainingPart && content.startsWith(remainingPart)) {
    return true;
  }
  if (includesNext) {
    return nextElementMaybeContinuesChars({
      elements,
      nextIndex: nextIndex + 1,
      remainingPart: remainingPart.replace(content, '')
    });
  }
  return false;
}
function getContent(node) {
  if (!node) return;
  return hastUtilToString.toString(node);
}
function findOverlap(a, b) {
  if (b.length === 0) {
    return '';
  }
  if (a.endsWith(b)) {
    return b;
  }
  if (a.indexOf(b) >= 0) {
    return b;
  }
  return findOverlap(a, b.substring(0, b.length - 1));
}
function reverseString(s) {
  return s.split('').reverse().join('');
}

function getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {
  const toWrap = [];
  let charsSoFar = '';
  if (element.children) {
    const elements = element.children;
    for (let i = startIndex; i < elements.length; i++) {
      const remaining = charsSoFar ? chars.replace(charsSoFar, '') : chars;
      if (remaining === '') {
        return toWrap;
      }
      const maybeElement = elements[i];
      if (!maybeElement || maybeElement.type !== 'element' ||
      // ignore any previously matched chars within
      hasOwnProperty(maybeElement.properties ?? {}, 'rehype-pretty-code-visited')) {
        continue;
      }
      const content = getContent(maybeElement) || '';

      // node is the chars, or it finishes the chars
      if (content === chars || charsSoFar + content === chars) {
        toWrap.push({
          element: maybeElement,
          index: i
        });
        return toWrap;
      }

      // check if the whole node is a continuation of the chars
      if (chars.startsWith(charsSoFar + content)) {
        // make sure we continue here only if further siblings
        // complete the chars. Otherwise an earlier repetition
        // of a section of the chars will lead us down the wrong path
        if (nextElementMaybeContinuesChars({
          elements,
          nextIndex: i + 1,
          remainingPart: remaining.replace(content, '')
        })) {
          toWrap.push({
            element: elements[i],
            index: i
          });
          charsSoFar += content;
          continue;
        }
      }
      const overlap = findOverlap(content, remaining);
      const partialMatch = overlap && remaining.startsWith(overlap);
      if (partialMatch) {
        const nextPart = remaining.replace(overlap, '');

        // this is the wrong node, continue
        if (nextPart !== '' && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({
          elements,
          nextIndex: i + 1,
          remainingPart: nextPart
        })) {
          continue;
        }
        const splitParts = content.split(overlap);
        const [leftPart, rightPart, ...rest] = splitParts;
        if (rightPart || leftPart || rest.length > 0) {
          // One of the below scenarios should be true
          // 1. the whole set of chars are inside the string (at least once) ca[rro]t
          // 2. the chars finish or start & end on the beginning of the string ...[carr]ot
          // 3. the chars start or start & end from the end of the string carr[ot]...

          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : '');
          const nextNodeOverlap = findOverlap(withNextNode, remaining);
          const splitIndex = withNextNode.indexOf(nextNodeOverlap);
          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {
            const rightString = rightPart.replace(overlap, '');
            const innerString = overlap;
            const leftString = content.substring(0, splitIndex);

            // need to check this to avoid edge case where the right
            // side will be duplicated when the matched part repeats within the
            // current node
            const nextElementContinues = nextElementMaybeContinuesChars({
              elements,
              nextIndex: i + 1,
              remainingPart: nextPart
            });
            const [newElement, updatedIndex] = splitElement({
              elements,
              elementToWrap: elements[i],
              innerString,
              rightString,
              leftString,
              rest,
              nextElementContinues,
              index: i,
              ignoreChars
            });
            charsSoFar += overlap;
            toWrap.push({
              element: newElement,
              index: updatedIndex
            });
          }
        }
      }
    }
  }
  return toWrap;
}

function wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {
  if (!elementsToWrap || elementsToWrap.length === 0) {
    return;
  }
  const [{
    element
  }] = elementsToWrap;
  if (ignoreWord) {
    if (element.properties) {
      element.properties['rehype-pretty-code-visited'] = '';
    }
    return;
  }
  if (elementsToWrap.length > 1) {
    parentElement.children.splice(elementsToWrap[0].index, elementsToWrap.length, {
      type: 'element',
      tagName: 'span',
      properties: {
        'data-highlighted-chars-wrapper': ''
      },
      children: elementsToWrap.map(({
        element
      }) => element)
    });
    const element = parentElement.children[elementsToWrap[0].index];
    if (!isElement(element)) {
      return;
    }
    const wordStr = element.children.reduce((acc, node) => {
      const textElement = isElement(node) ? node.children[0] : null;
      if (isText(textElement)) {
        return acc + textElement.value;
      }
      return acc;
    }, '');
    const id = options.idsMap.get(wordStr);
    element.properties = element.properties || {};
    element.properties['data-highlighted-chars'] = '';
    element.properties['data-chars-id'] = id;
    onVisitHighlightedChars?.(element, id);
  } else {
    const [{
      element
    }] = elementsToWrap;
    const textElement = element.children[0];
    if (!isText(textElement)) {
      return;
    }
    const id = options.idsMap.get(textElement.value);
    element.properties = element.properties || {};
    // used to skip already parsed chars
    element.properties['rehype-pretty-code-visited'] = '';
    element.properties['data-highlighted-chars'] = '';
    element.properties['data-chars-id'] = id;
    onVisitHighlightedChars?.(element, id);
  }
}

/**
 * Loops through the child nodes and finds the nodes that make up the chars.
 * If the chars cross node boundaries, those nodes are wrapped with
 * <span data-highlighted-chars-wrapper>, and that node is passed to
 * onVisitHighlightedChars.
 *
 * If a node partially matches the chars, its content is replaced with the
 * matched part, and the left and/or right parts are cloned to sibling nodes.
 */
function charsHighlighter(element, charsList, options, onVisitHighlightedChars) {
  const {
    ranges = []
  } = options;
  const textContent = hastUtilToString.toString(element);
  charsList.forEach((chars, index) => {
    if (chars && textContent?.includes(chars)) {
      let textContent = hastUtilToString.toString(element);
      let startIndex = 0;
      while (textContent.includes(chars)) {
        const currentCharsRange = ranges[index] || [];
        const id = `${chars}-${index}`;
        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);
        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);
        const elementsToWrap = getElementsToHighlight(element, chars, startIndex, ignoreChars);

        // maybe throw / notify due to failure here
        if (elementsToWrap.length === 0) break;
        wrapHighlightedChars(element, elementsToWrap, options, ignoreChars, onVisitHighlightedChars);

        // re-start from the 'last' node (the chars or part of them may exist
        // multiple times in the same node)
        // account for possible extra nodes added from split with - 2
        startIndex = Math.max(elementsToWrap[elementsToWrap.length - 1].index - 2, 0);
        textContent = element.children.map(childNode => {
          const props = isElement(childNode) ? childNode.properties : {};
          if (props && !hasOwnProperty(props, 'rehype-pretty-code-visited') && !hasOwnProperty(props, 'data-highlighted-chars-wrapper')) {
            return hastUtilToString.toString(childNode);
          }
        }).join('');
      }
    }
    element.children.forEach(childNode => {
      if (!isElement(childNode)) {
        return;
      }
      if (hasOwnProperty(childNode.properties ?? {}, 'rehype-pretty-code-visited')) {
        if (childNode.properties) {
          delete childNode.properties['rehype-pretty-code-visited'];
        }
      }
    });
  });
}

function toFragment(element, {
  trees,
  lang,
  title,
  caption,
  inline = false,
  keepBackground = true,
  grid = true,
  lineNumbersMaxDigits = 1,
  onVisitTitle,
  onVisitCaption
}) {
  element.tagName = inline ? 'span' : 'div';
  // User can replace this with a real Fragment at runtime
  element.properties = {
    'data-rehype-pretty-code-fragment': ''
  };
  element.children = Object.entries(trees).map(([mode, tree]) => {
    const pre = tree.children[0];
    if (!isElement(pre) || !pre.properties) {
      return [];
    }
    const code = pre.children[0];

    // Remove class="shiki"
    if (Array.isArray(pre.properties?.className) && pre.properties?.className.includes('shiki')) {
      const className = pre.properties.className.filter(c => c !== 'shiki');
      pre.properties.className = className.length > 0 ? className : undefined;
    }
    if (!keepBackground) {
      pre.properties.style = undefined;
    }
    pre.properties['data-language'] = lang;
    pre.properties['data-theme'] = mode;
    if (!isElement(code) || !code.properties) {
      return [];
    }
    code.properties['data-language'] = lang;
    code.properties['data-theme'] = mode;
    if (inline) {
      if (keepBackground) {
        code.properties.style = pre.properties.style;
      }
      return code;
    }
    if (grid) {
      if (code.properties.style) {
        code.properties.style += 'display: grid;';
      } else {
        code.properties.style = 'display: grid;';
      }
    }
    if ('data-line-numbers' in code.properties) {
      code.properties['data-line-numbers-max-digits'] = lineNumbersMaxDigits.toString().length;
    }
    const fragments = [];
    if (title) {
      const elementContent = {
        type: 'element',
        tagName: 'div',
        properties: {
          'data-rehype-pretty-code-title': '',
          'data-language': lang,
          'data-theme': mode
        },
        children: [{
          type: 'text',
          value: title
        }]
      };
      onVisitTitle?.(elementContent);
      fragments.push(elementContent);
    }
    fragments.push(pre);
    if (caption) {
      const elementContent = {
        type: 'element',
        tagName: 'div',
        properties: {
          'data-rehype-pretty-code-caption': '',
          'data-language': lang,
          'data-theme': mode
        },
        children: [{
          type: 'text',
          value: caption
        }]
      };
      onVisitCaption?.(elementContent);
      fragments.push(elementContent);
    }
    return fragments;
  }).flatMap(c => c);
}
const globalHighlighterCache = new Map();
const hastParser = unified.unified().use(rehypeParse__default["default"], {
  fragment: true
});
function rehypePrettyCode(options = {}) {
  const {
    grid = true,
    theme = 'github-dark-dimmed',
    keepBackground = true,
    defaultLang = '',
    tokensMap = {},
    filterMetaString = v => v,
    getHighlighter = shiki.getHighlighter,
    onVisitLine,
    onVisitHighlightedLine,
    onVisitHighlightedChars,
    onVisitTitle,
    onVisitCaption
  } = options;
  const optionsHash = hashObj__default["default"]({
    theme,
    tokensMap,
    onVisitLine,
    onVisitHighlightedLine,
    onVisitHighlightedChars,
    getHighlighter
  }, {
    algorithm: 'sha1'
  });
  let highlighterCache = globalHighlighterCache.get(optionsHash);
  if (!highlighterCache) {
    highlighterCache = new Map();
    globalHighlighterCache.set(optionsHash, highlighterCache);
  }
  const highlighters = new Map();
  const defaultCodeBlockLang = typeof defaultLang === 'string' ? defaultLang : defaultLang.block || '';
  const defaultInlineCodeLang = typeof defaultLang === 'string' ? defaultLang : defaultLang.inline || '';
  if (theme == null || typeof theme === 'string' || isShikiTheme(theme)) {
    if (!highlighterCache.has('default')) {
      highlighterCache.set('default', getHighlighter({
        theme
      }));
    }
  } else if (typeof theme === 'object') {
    // color mode object
    for (const [mode, value] of Object.entries(theme)) {
      if (!highlighterCache.has(mode)) {
        highlighterCache.set(mode, getHighlighter({
          theme: value
        }));
      }
    }
  }
  return async tree => {
    if (!highlighterCache) return;
    for (const [mode, loadHighlighter] of highlighterCache.entries()) {
      if (!highlighters.get(mode)) {
        highlighters.set(mode, await loadHighlighter);
      }
    }
    unistUtilVisit.visit(tree, 'element', (element, index, parent) => {
      // Inline code
      if (element.tagName === 'code' && isElement(parent) && parent.tagName !== 'pre' || element.tagName === 'inlineCode') {
        const textElement = element.children[0];
        if (!isText(textElement)) {
          return;
        }
        const value = textElement.value;
        if (!value) {
          return;
        }

        // TODO: allow escape characters to break out of highlighting
        const strippedValue = value.replace(/{:[a-zA-Z.-]+}/, '');
        const meta = value.match(/{:([a-zA-Z.-]+)}$/)?.[1] || defaultInlineCodeLang;
        if (!meta) {
          return;
        }
        const isLang = meta[0] !== '.';
        const trees = {};
        for (const [mode, highlighter] of highlighters.entries()) {
          if (!isLang || meta === 'ansi' && !highlighter.ansiToHtml) {
            const color = highlighter.getTheme().settings.find(({
              scope
            }) => scope?.includes(tokensMap[meta.slice(1)] ?? meta.slice(1)))?.settings.foreground ?? 'inherit';
            trees[mode] = hastParser.parse(`<pre><code><span style="color:${color}">${strippedValue}</span></code></pre>`);
          } else {
            let html;
            if (meta === 'ansi') {
              html = highlighter.ansiToHtml(strippedValue);
            } else {
              html = highlighter.codeToHtml(strippedValue, meta);
            }
            trees[mode] = hastParser.parse(html);
          }
        }
        toFragment(element, {
          trees,
          lang: isLang ? meta : '.token',
          inline: true,
          keepBackground
        });
      }
      if (
      // Block code
      // Check from https://github.com/leafac/rehype-shiki
      element.tagName === 'pre' && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === 'code') {
        const codeElement = element.children[0];
        const textElement = codeElement.children[0];
        if (!isElement(codeElement)) {
          return;
        }
        let lang = defaultCodeBlockLang;
        if (codeElement.properties && Array.isArray(codeElement.properties.className) && typeof codeElement.properties.className[0] === 'string' && codeElement.properties.className[0].startsWith('language-')) {
          lang = codeElement.properties.className[0].replace('language-', '');
        }
        const metastring = codeElement.data?.meta ?? codeElement.properties?.metastring ?? '';
        let meta = filterMetaString(metastring);
        const titleMatch = meta.match(/title="([^"]*)"/);
        const title = titleMatch?.[1] ?? null;
        meta = meta.replace(titleMatch?.[0] ?? '', '');
        const captionMatch = meta.match(/caption="([^"]*)"/);
        const caption = captionMatch?.[1] ?? null;
        meta = meta.replace(captionMatch?.[0] ?? '', '');
        const lineNumbers = meta ? rangeParser__default["default"](meta.match(/(?:^|\s){(.*?)}/)?.[1] ?? '') : [];
        let lineNumbersMaxDigits = 0;
        const words = [];
        const wordNumbers = [];
        const wordIdsMap = new Map();
        const wordMatches = meta ? [...meta.matchAll(/\/(.*?)\/(\S*)/g)] : undefined;
        if (Array.isArray(wordMatches)) {
          wordMatches.forEach((_, index) => {
            const word = wordMatches[index][1];
            const wordIdAndOrRange = wordMatches[index][2];
            words.push(word);
            const [range, id] = wordIdAndOrRange.split('#');
            if (range) {
              wordNumbers.push(rangeParser__default["default"](range));
            }
            if (id) {
              wordIdsMap.set(word, id);
            }
          });
        }
        if (!isText(textElement)) {
          return;
        }
        const strippedValue = textElement.value.replace(/\n$/, '');
        const trees = {};
        for (const [mode, highlighter] of highlighters.entries()) {
          try {
            let html;
            if (lang === 'ansi' && highlighter.ansiToHtml) {
              html = highlighter.ansiToHtml(strippedValue);
            } else {
              html = highlighter.codeToHtml(strippedValue, lang);
            }
            trees[mode] = hastParser.parse(html);
          } catch (e) {
            // Fallback to plain text if a language has not been registered
            trees[mode] = hastParser.parse(highlighter.codeToHtml(strippedValue, 'txt'));
          }
        }
        Object.entries(trees).forEach(([, tree]) => {
          let lineCounter = 0;
          const wordOptions = {
            ranges: wordNumbers,
            idsMap: wordIdsMap,
            counterMap: new Map()
          };
          unistUtilVisit.visit(tree, 'element', element => {
            if (element.tagName === 'code' && /srebmuNeniLwohs(?!(.*)(\/))/.test(reverseString(meta))) {
              if (element.properties) {
                element.properties['data-line-numbers'] = '';
              }
              const lineNumbersStartAtMatch = reverseString(meta).match(/(?:\}(\d+){)?srebmuNeniLwohs(?!(.*)(\/))/);
              const startNumberString = lineNumbersStartAtMatch?.[1];
              if (startNumberString) {
                const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;
                lineNumbersMaxDigits = startAt;
                if (element.properties) {
                  element.properties.style = `counter-set: line ${startAt};`;
                }
              }
            }
            if (Array.isArray(element.properties?.className) && element.properties?.className?.[0] === 'line') {
              if (grid && element.children.length === 0) {
                element.children = [{
                  type: 'text',
                  value: ' '
                }];
              }
              const className = element.properties.className.filter(c => c !== 'line');
              element.properties.className = className.length > 0 ? className : undefined;
              element.properties['data-line'] = '';
              onVisitLine?.(element);
              if (lineNumbers.length !== 0 && lineNumbers.includes(++lineCounter)) {
                element.properties['data-highlighted-line'] = '';
                onVisitHighlightedLine?.(element);
              }
              charsHighlighter(element, words, wordOptions, onVisitHighlightedChars);
              lineNumbersMaxDigits++;
            }
          });
        });
        toFragment(element, {
          trees,
          lang,
          title,
          caption,
          keepBackground,
          grid,
          lineNumbersMaxDigits,
          onVisitTitle,
          onVisitCaption
        });
      }
    });
  };
}

module.exports = rehypePrettyCode;
